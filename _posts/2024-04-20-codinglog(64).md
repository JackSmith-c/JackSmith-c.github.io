---
layout: single
title: '코딩일지(2024-04-20)'
categories:
  - Docker
tags:
  - shell
toc: true
toc_sticky: true
typora-root-url: ../
---



# CIDR를 배우고 IP주소를 효과적으로 관리하는 방법을 알았다.

CIDR를 배우고 IP주소를 효과적으로 관리하는 방법을 알았다.

기존에 책에서는 IP주소를 관리하는 방법으로 클래스별로 구분하는 방법을 배웠었다.

A클래스로 묶인 IP주소는 어디서 주로 쓰고, B클래스로 묶인 IP주소는 어디서 주로 쓰는지 등을 배웠었다.



> 하지만 이는 이제 구닥다리 방식으로 여겨지는 것 같다.

![Wow-gif](/images/2024-04-20-codinglog(64)/Wow-gif.webp)

이제는 **주소**와 **서브넷마스크**를 적절히 활용하여 네트워크를 보다 더 유동적으로 활용할 수 있게 된 것이다.



## CIDR 표기법이 머고?

![WINWORD_H9WvZnty3m](/images/2024-04-20-codinglog(64)/WINWORD_H9WvZnty3m.webp)

CIDR 표기법은 IP주소 뒤에 슬래시('/')를 붙이고 접두사 길이를 표시하는 형식이다. 
예를 들어보자.
현재 내 라즈베리파이에 할당된 주소는 192.168.1.0/24이다. 여기서 192.168.1.0는 IP주소를, 24는 접두사 길이를 의미한다. 접두사 길이를 어려운게 아니고 서브넷마스크의 길이를 의미하며, 네트워크 부분의 비트수를 지정한다. 마스크의 길이가 길면 네트워크의 비트수가 커지고 이는 네트워크망을 더 잘게 쪼갠다는 것을 의미한다. 반대로 마스크의 길이가 짧으면 네트워크의 비트수가 작아지고 이는 네트워크망을 크게 뭉뚱그려? 쪼갠다.



## 구성요소를 다시 보자

1. IP주소: 네트워크 식별자
2. 접두사 길이: 네트워크수와 호스트 수를 구분짓는 비트수(보통 24로 잡는다. 내가 있는 연구실도 24이다)



## 주소 블록에서 정보를 추출하는 법

CIDR 블록에서 정보를 추출하기 위해서는 블록의 네트워크 주소, 첫번째 주소, 마지막 주소를 반드시 알아야 한다고 한다.

- 네트워크 주소: 접두사 길이만큼의 비트를 유지, 나머지 비트는 0으로 reset
- 첫번째 주소: 네트워크 주소와 동일
- 마지막 주소: 네트워크 주소의 나머지 비트를 1로 설정하여 계산



## 어떤 점에서 유용할까?

이 방식이 이전 클래스 방식에 비해 어떤 점에서 유요한지 알아보았다.

- 효율적인 주소 사용: IP주소공간을 보다 효율적으로 사용할 수 있다
- 라우팅 최적화: 라우팅 테이블의 크기를 줄여 네트워크 성능을 향상시킬 수 있다
- 유연한 서브넷 관리: 다양한 크기으 서브넷을 쉽게 설정할 수 있어 네트워크 관리가 편리하다

결론적으로, CIDR은 IP주소 공간을 효율적으로 사용하고, 라우팅 테이블의 크기를 줄이는 데 큰 역할을 한다. 또한, 서브넷을 유연하게 관리할 수 있어 네트워크 설계와 관리에 유용하다고 한다.

